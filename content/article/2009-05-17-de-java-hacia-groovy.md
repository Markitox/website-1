---title: 'De Java hacia Groovy'author: MIguel-1.mxdate: 2009-05-17url: /2009/05/17/de-java-hacia-groovy/categories:  - Groovy---<!--originalDate: 2009-06-19-->  As&iacute; como para aprender a conducir se necesita conducir, o para aprender a besar se necesita besar, Groovy se aprende con Groovy. En el taller de Groovy impartido por el Ing. Domingo Suarez, como parte de la sexta reuni&oacute;n de SpringHispano.org y JavaMexico.org se incluy&oacute; la siguiente charla, que me pareci&oacute; oportuna como punto de comparaci&oacute;n entre Groovy y Java. Se mostr&oacute; mediante ejemplos la compatibilidad entre Groovy y Java: un programa para la consola escrito en Java:<!-- break --><p align='justify'>  HelloWorld en Java:</p><pre class='brush:java'>public class HelloWorld {    String name;     public void setName(String name)    { this.name = name; }    public String getName() { return name; }     public String greet()    { return 'Hello '+ name; }     public static void main(String args[]){       HelloWorld helloWorld = new HelloWorld()       helloWorld.setName('Groovy')       System.err.println( helloWorld.greet() )    } } </pre><p align='justify'>  Enseguida, el HelloWorld en Groovy:</p><pre class='brush:groovy'>public class HelloWorld {    String name;     public void setName(String name)    { this.name = name; }    public String getName() { return name; }     public String greet()    { return 'Hello '+ name; }     public static void main(String args[]){       HelloWorld helloWorld = new HelloWorld()       helloWorld.setName('Groovy')       System.err.println( helloWorld.greet() )    } } </pre><p align='justify'>  Muy bien. Entonces, &iquest;cu&aacute;l es la diferencia? Ah, este ejercicio no mostraba la manera de trabajar con Groovy, sino que la curva de aprendizaje para un programador de Java es pr&aacute;cticamente de cero, es decir, si no recuerdan o no conocen c&oacute;mo opera Groovy en alg&uacute;n punto espec&iacute;fico, se puede escribir la porci&oacute;n en cuesti&oacute;n v&iacute;a Java con el mismo resultado, pues pr&aacute;cticamente cualquier c&oacute;digo en Java se puede trasladar a Groovy (son muy pocas las incompatibilidades). &iquest;Y cu&aacute;les son las ventajas? Se describieron poco a poco:</p><p align='justify'>  Groovy tiene la noci&oacute;n de &#8216;convenci&oacute;n sobre configuraci&oacute;n&#8217;, en otras palabras, no da suma importancia a los detallazos como el punto y coma tras cada oraci&oacute;n, y todo en Groovy es p&uacute;blico a menos que se especifique lo contrario. Con estos dos puntos, se comenz&oacute; el camino del HelloWorld hacia la manera de Groovy:</p><p align='justify'>  Hacia el HelloWorld de la manera Groovy (1):</p><pre class='brush:groovy'>class HelloWorld {    String name     void setName(String name)    { this.name = name }    String getName() { return name }     String greet()    { return 'Hello '+ name }     static void main(String args[]){       HelloWorld helloWorld = new HelloWorld()       helloWorld.setName('Groovy')       System.err.println( helloWorld.greet() )    } } </pre><p align='justify'>  En este orden de ideas, Groovy llama &#8216;datos b&aacute;sicos&#8217; (o &#8216;boilerplate&#8217; en ingl&eacute;s) a la informaci&oacute;n fundamental de la organizaci&oacute;n al inicio de cualquier programa en Java: todos sabemos que para programar un JavaBean se requiere un par de get/set para cada propiedad: dejemos que Groovy lo escriba por uno. Lo mismo con Main(): siempre requiere String[] como par&aacute;metro. Dejemos que Groovy haga esa definici&oacute;n m&aacute;s corta con tipos opcionales. Enseguida, si imprimir a la consola es tan com&uacute;n, &iquest;podemos tener una versi&oacute;n m&aacute;s corta tambi&eacute;n?. Con Groovy, s&iacute;. Veamos c&oacute;mo queda:</p><p align='justify'>  Hacia el HelloWorld de la manera Groovy (2):</p><pre class='brush:groovy'>class HelloWorld {    String name     String greet()    { return 'Hello '+ name }     static void main( args ){       HelloWorld helloWorld = new HelloWorld()       helloWorld.setName('Groovy')       println( helloWorld.greet() )    } } </pre><p align='justify'>  Groovy usa la palabra clave def cuando no es indispensable indicar el tipo de variable, de manera similar a la palabra clave var en JavaScript. De esta manera Groovy deducir&aacute; el tipo correcto. A esto se le llama ordenamiento de tipos din&aacute;micos (duck typing en ingl&eacute;s):</p><p align='justify'>  Hacia el HelloWorld de la manera Groovy (3):</p><pre class='brush:groovy'>class HelloWorld {    String name     def greet()    { return 'Hello '+ name }     static def main( args ){       def helloWorld = new HelloWorld()       helloWorld.setName('Groovy')       println( helloWorld.greet() )    } } </pre><p align='justify'>  Los GStrings proporcionan interpolaci&oacute;n de variable, como en Ruby o Python: Con anteceder ${} dentro de un String bastar&aacute;:</p><p align='justify'>  Hacia el HelloWorld de la manera Groovy (4):</p><pre class='brush:groovy'>class HelloWorld {    String name     def greet() { return 'Hello ${name}' }     static def main( args ){       def helloWorld = new HelloWorld()       helloWorld.setName('Groovy')       println( helloWorld.greet() )    } } </pre><p align='justify'>  Ahora bien, no es necesario usar &#8216;def&#8217; en m&eacute;todos est&aacute;ticos, y es opcional la palabra clave &#8216;return': el valor de retorno de un m&eacute;todo ser&aacute; la &uacute;ltima expresi&oacute;n evaluada. En Groovy se traduce:</p><p align='justify'>  Hacia el HelloWorld de la manera Groovy (5):</p><pre class='brush:groovy'>class HelloWorld {    String name     def greet() { return 'Hello ${name}' }     static main( args ){       def helloWorld = new HelloWorld()       helloWorld.setName('Groovy')       println( helloWorld.greet() )    } } </pre><p align='justify'>  Acto seguido, el concepto de POJOs en esteroides. Los POJOs no s&oacute;lo escriben sus propios accesorios de propiedad. Los POGOs (manera Groovy) tambi&eacute;n proporcionan un constructor predeterminado con par&aacute;metros (s&iacute;miles) nombrados; adem&aacute;s, soporte para subscripts de arreglo (bean[prop]) y notaci&oacute;n de punto (bean.prop) para acceder a propiedades:</p><p align='justify'>  Hacia el HelloWorld de la manera Groovy (6):</p><pre class='brush:groovy'>class HelloWorld {    String name     def greet() { return 'Hello ${name}' }     static main( args ){       def helloWorld = new                HelloWorld(name:'Groovy')       helloWorld.name = 'Groovy'       helloWorld['name'] = 'Groovy'       println( helloWorld.greet() )    } } </pre><p align='justify'>  Por &uacute;ltimo (para esta demostraci&oacute;n), Groovy soporta scripts (aunque compile clases a c&oacute;digo de byte Java), y esos scripts tambi&eacute;n se compilan a c&oacute;digo de byte Java. Dichos scripts permite que se definan clases en cualquier lugar sobre ellos y soportan paquetes, pues tambi&eacute;n son clases Java v&aacute;lidos.</p><p align='justify'>  HelloWorld a la manera Groovy (7):</p><pre class='brush:groovy'>class HelloWorld {    String name    def greet() { return 'Hello ${name}' } }     def helloWorld = new HelloWorld(name:'Groovy')       println( helloWorld.greet() ) </pre><p align='justify'>  Contra esta &uacute;ltima versi&oacute;n hay un abismo de diferencia con el primer ejemplo, en Java. No obstante, sigue siendo Java. Groovy sigue el &#8216;mantra': Java es Groovy, Groovy es Java&#8217;, y aqu&iacute; se demuestra la compatibilidad a su m&aacute;xima expresi&oacute;n. Casi el 98% del c&oacute;digo Java es compatible con c&oacute;digo Groovy. Podr&iacute;a cambiar la extensi&oacute;n de *.java a *.groovy y funcionar&aacute;.</p>